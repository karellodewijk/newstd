#ifndef STL_VECTOR_H
#define STL_VECTOR_H

#include <memory>
#include <iostream>
#include <cstring>

namespace std {

template <class T, class Allocator = allocator<T> >
class vector {
  private:
    static constexpr float GROWTH_RATIO = 2.0f; //when the vector needs to grow it will increase by this amount
  
    T* m_begin;
    T* m_end;
    T* m_memory_end;
    Allocator m_alloc;

  public:

// types:
    typedef T value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator; // see 23.2
    typedef const value_type* const_iterator; // see 23.2
    typedef size_t size_type; // see 23.2
    typedef ptrdiff_t difference_type; // see 23.2
    typedef Allocator allocator_type;
    typedef typename allocator_traits<Allocator>::pointer pointer;
    typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  private:
  
    //Either copy n x T from begin to dst or if that fails, destroy everything copied so far, deallocate dest and throw 
    void copy_or_cleanup(T* begin, T*& dest, size_type n, size_type alloc_size) {
        size_type i = 0;
        try {
            for (; i < n; ++i)
                m_alloc.construct(dest+i, std::move_if_noexcept(*(begin+i)));
        } catch (...) {
            for (; i > 0; --i)
                m_alloc.destroy(dest-i-1);   
            m_alloc.deallocate(dest, alloc_size);
            throw;
        }
        for (i = 0; i < n; ++i)
            m_alloc.destroy(begin);
    }

    //Either initialize n x T at begin or if that fails, clean up
    template <class... Args>  
    void initialize_or_cleanup(T*& begin, T*& end, T*& memory_end, Args&&... args) {
        auto it = begin;
        try {
            for (; it != end; ++it)
                m_alloc.construct(it, std::forward<Args>(args)...);
        } catch (...) {
            while (it != begin)
                m_alloc.destroy(--it);
            m_alloc.deallocate(begin, memory_end - begin);
            begin = nullptr;
            end = nullptr;
            memory_end = nullptr;
            throw;
        }
    }

    //Either initialize n x T at begin or if that fails, clean up
    template <class Iterator, class... Args>
    void initialize_or_cleanup(T*& begin, T*& end, T*& memory_end, Iterator first, Iterator last) {
        auto it = begin;
        try {
            for (; it != end; ++first, ++it)
                m_alloc.construct(it, *first);
        } catch (...) {
            while (it != begin)
                m_alloc.destroy(--it);
            m_alloc.deallocate(begin, memory_end - begin);
            begin = nullptr;
            end = nullptr;
            memory_end = nullptr;
            throw;
        }
    }
  

    
public:

// 23.3.6.2, construct/copy/destroy:
    explicit vector(const Allocator& alloc = Allocator()) : m_begin(nullptr), m_end(nullptr), m_memory_end(nullptr), m_alloc(alloc) {}
    
    explicit vector(size_type n) : m_alloc(Allocator()), m_begin(m_alloc.allocate(n)), m_end(m_begin+n), m_memory_end(m_end) {
        initialize_or_cleanup(m_begin, m_end, m_memory_end);
    }    
    
    vector(size_type n, const T& value, const Allocator& alloc = Allocator()) : m_alloc(alloc), m_begin(m_alloc.allocate(n)), m_end(m_begin+n), m_memory_end(m_end) {
        initialize_or_cleanup(m_begin, m_end, m_memory_end, value);
    }

    //just for input iterators, just ignore the sfinae part, I always do
    template <class InputIterator, typename enable_if<is_same<typename std::iterator_traits<InputIterator>::iterator_category, input_iterator_tag>::value, int>::type = 0>
    vector(InputIterator first, InputIterator last, const Allocator& alloc = Allocator()) : vector(alloc) {
        for (; first != last; ++first)
            emplace_back(*first);
    }

private:
    template <class InputIterator>
    vector(size_type n, InputIterator first, InputIterator last, const Allocator& alloc = Allocator()) 
        : m_alloc(alloc)
        , m_begin(m_alloc.allocate(n))
        , m_end(m_begin + n)
        , m_memory_end(m_end) 
    {
        initialize_or_cleanup(m_begin, m_end, m_memory_end, first, last);
    }

public:
    //all other iterators, just ignore the sfinae part, I always do
    template <class InputIterator, typename enable_if<!is_same<typename std::iterator_traits<InputIterator>::iterator_category, input_iterator_tag>::value, int>::type = 0>
    vector(InputIterator first, InputIterator last, const Allocator& alloc = Allocator()) 
        : vector(std::distance(first, last), first, last, alloc) //just delegate to the constructor bove with distance(first, last) calculated so I can use it twice without calculating it twice
    {}

    vector(const vector& x, const Allocator& alloc) : vector(x.begin(), x.end(), alloc) {}
    
    vector(const vector<T,Allocator>& x) : vector(x, x.get_allocator()) {}
        
    vector(vector&& x, const Allocator& alloc) : m_alloc(alloc), m_begin(x.m_begin), m_end(x.m_end), m_memory_end(x.m_memory_end) {
        x.m_begin(nullptr);
        x.m_end(nullptr);
        x.m_memory_end(nullptr);
    }

    vector(vector&& x) : vector(std::move(x), x.get_allocator()) {}
    
    vector(initializer_list<T> x, const Allocator& alloc = Allocator()) : vector(x.begin(), x.end(), alloc) {}
    
    ~vector() { clear(); }
    
    vector<T,Allocator>& operator=(const vector<T,Allocator>& x) {
        for (auto it = m_begin; it != m_end; ++it)
            m_alloc.destroy(it);
        if (capacity() < x.size()) {
            m_alloc.dealloc(m_begin, capacity());
            m_begin = m_alloc.allocate(x.size(), x.m_begin);
            m_end(m_begin+x.size());
            m_memory_end(m_end);
            initialize_or_cleanup(m_begin, m_end, m_memory_end, x.begin(), x.end());
        }
    }
    
    vector<T,Allocator>& operator=(vector<T,Allocator>&& x) {
        clear();
        
        //steal data
        m_alloc = x.m_alloc;
        m_begin = x.m_begin;
        m_end = x.m_end;
        m_memory_end = x.m_memory_end;
        
        //zero out other
        x.m_begin(nullptr);
        x.m_end(nullptr);
        x.m_memory_end(nullptr);        
    }
    
    
    vector& operator=(initializer_list<T> x);
    
    
    template <class InputIterator>
    void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& u);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept { return m_alloc; }

// iterators:
    iterator begin() noexcept { return m_begin; }
    const_iterator begin() const noexcept { return m_begin; }
    iterator end() noexcept { return m_end; }
    const_iterator end() const noexcept { return m_end; }
    reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }
    reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
    const_reverse_iterator  rend() const noexcept { return const_reverse_iterator(cbegin()); }
    const_iterator cbegin() const noexcept { return m_begin; }
    const_iterator cend() const noexcept { return m_end; }
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
    const_reverse_iterator  crend() const noexcept { return const_reverse_iterator(cbegin()); }
    
// 23.3.6.3, capacity:
    size_type size() const noexcept { return m_end - m_begin; }
    size_type max_size() const noexcept { return std::min(size_type(-1)/sizeof(T), m_alloc.max_size()); }  
    
    void resize(size_type sz) {
        if (sz > size())
            insert(end(), sz-size());
        else if (sz < size())
            erase(begin()+sz, end());
    }
    
    void resize(size_type sz, const T& c) {
        if (sz > size())
            insert(end(), sz-size(), c);
        else if (sz < size())
            erase(begin()+sz, end());
    }
    
    size_type capacity() const noexcept { return m_memory_end - m_begin; }
    bool empty() const noexcept { m_begin == m_end; }
    
    void reserve(size_type n) {
        if (capacity() < n) {
            if (n > max_size())
                throw length_error("Reserve size exceeds capacity");
            T* tmp = m_alloc.allocate(n);
            copy_or_cleanup(m_begin, tmp, size(), n);
            m_alloc.deallocate(m_begin, capacity());
            m_end = tmp + size();
            m_begin = tmp;
            m_memory_end = m_begin+n;
        }
    }
    
    void shrink_to_fit() {
        if (size() > capacity()) {
            T* tmp = m_alloc.allocate(size());
            copy_or_cleanup(m_begin, tmp, size(), size());
            m_alloc.deallocate(m_begin, capacity());
            m_end = m_memory_end = tmp + size();
            m_begin = tmp;
        }
    }
    
// element access:
    reference operator[](size_type n) { return *(m_begin + n); }    
    const_reference operator[](size_type n) const { return *(m_begin + n); }
    
    const_reference at(size_type n) const { 
        if (n >= size()) 
            throw out_of_range("Index out of bounds"); 
        else 
            return *(m_begin + n); 
    }
    
    reference at(size_type n) { 
        if (n >= size()) 
            throw out_of_range("Index out of bounds"); 
        else 
            return *(m_begin + n); 
    }
    
    reference front() { return *m_begin; }
    const_reference front() const { return *m_begin; }
    reference back() { return *(m_end-1); }
    const_reference back() const{ return *(m_end-1); }

// 23.3.6.4, data access
    T* data() noexcept { return m_begin; }
    const T* data() const noexcept { return m_begin; }
    
// 23.3.6.5, modifiers:
    template <class... Args> void emplace_back(Args&&... args) {
        if (size() == capacity()) //no more room
            reserve(std::max(1, size()) * GROWTH_RATIO);
        T* el = m_end++;
        try {
            m_alloc.construct(el, std::forward<Args>(args)...);
        } catch(...) {
            --m_end();
            throw;
        }
    }
    
    void push_back(const T& x) { emplace_back(x); }
    void push_back(T&& x) { emplace_back(std::move(x)); }
    void pop_back() { m_alloc.destroy(--m_end); }
    
    template <class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const T& x);
    iterator insert(const_iterator position, T&& x);
    iterator insert(const_iterator position, size_type n, const T& x);
    template <class InputIterator>
    iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<T> il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(vector<T,Allocator>&);
    void clear() noexcept {
        for (auto it = m_begin; it != m_end; ++it)
            m_alloc.destroy(it);
        m_alloc.deallocate(m_begin, capacity());
    }
};

template <class T, class Allocator>
bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator>
bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator>
bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator>
bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator>
bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator>
bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

// 23.3.6.6, specialized algorithms:
template <class T, class Allocator>
void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);


} //end namespace std

#endif //end namespace STL_VECTOR_H
